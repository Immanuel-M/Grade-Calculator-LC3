;Robert Hinojo & Immanuel Morris
;CIS-11 Final Project (Spring 2022)
;LC-3 Grade Test Score Calculator

;Description: The purpose of this program is to calculate the numerical input
;from a user, and convert the decimal value into a letter grade.
;Additionally, The program is to display a minimum, maximum, and average value.



; START PROGRAM
.ORIG x3000


; MAIN
AND R1, R1, #0		; CLEARS R1		
AND R2, R2, #0		; CLEARS R2	
LOOPSTART
JSR CLEARS                  		
LEA R0, USERINPUT					
PUTS				
ADD R0, R1, #1				
JSR DISPLAYNUMBER           		
LEA R0, ENDCHECK				
PUTS
ADD R0, R2, #0		; COPY R2 TO R0			
JSR DIGITNUMBER				
JSR DISPLAYNUMBER				

GETC			; ASCII		
ADD R6, R0, x-A				
BRz NEXTGRADE			
ADD R6, R0, x-8				
BRnp BRANCHGRADE
ADD R2, R2, #0		; CLEARS R2			
BRnz LOOPSTART
JSR POP					
ADD R2, R2, #-1		; SUBTRACT 1 TO TEST FOR SIGN		
BRnzp LOOPSTART
BRANCHGRADE

ADD R6, R2, #-3				
BRzp LOOPSTART 
LD R3, NEGCHARACTERCOMP		
ADD R0, R0, R3
BRn LOOPSTART				
ADD R3, R6, #-9				
BRp LOOPSTART			
JSR PUSH					
ADD R2, R2, #1		; #1 ;2S COMPLIMENT				
BRnzp LOOPSTART		
NEXTGRADE
ADD R0, R2, #0		; COPY R2 TO R0
JSR DIGITNUMBER 			
ADD R6, R0, #0		; COPY R0 TO R6	

DIGITCLEAR
ADD R2, R2, #-1		; SUBTRACT 1 TO TEST FOR SIGN			
BRn CLEAR
JSR POP				
BRnzp DIGITCLEAR
CLEAR
ADD R0, R6, #0        	; COPY R6 TO R0      	
JSR PUSH				
ADD R1, R1, #1		; #1 ;2S COMPLIMENT        
AND R2, R2, #0	  	; CLEARS R2	
LD R3, LOOPCOUNTER
ADD R3, R3, R1
BRn LOOPSTART			

LD R1, POINTER
LD R3, STACKSIZE
NOT R3, R3		; INVERTED IT
ADD R3, R3, #1		; #1 ;2S COMPLIMENT
AND R6, R6, #0		; CLEARS R6		 
ADD R6, R6, #1		; #1 ;2S COMPLIMENT
AND R4, R4, #0		; CLEARS R4		
LD R2, BASEMINIMUM		
ST R2, MIN		; STORE VALUE TO MIN
LD R2, BASEMAXIMUM
ST R2, MAX		; STORE VALUE TO MAX
JSR CLEARS                  	

; MAIN OUTPUT
OUTPUTLOOP
ADD R2, R6, R3		
BRp ENDOUTPUTLOOP
LEA R0, OUTPUTGRADE         	
PUTS
ADD R0, R6, #0		; COPY R6 TO R0	
JSR DISPLAYNUMBER           	
LEA R0, ENDCHECK            
PUTS
ADD R2, R1, R6              
LDR R0, R2, #0		; COPY R2 TO R0	 
JSR DISPLAYNUMBER			
ADD R2, R0, #0		; COPY R0 TO R2
LD R0, SPACE		
OUT						
ADD R0, R2, #0		; COPY R2 TO R0	
JSR DISPLAYSGRADE 			

; MINIMUM, MAXIMUM, AVERAGE OUTPUT
   
; CHECK FOR MINIMUM 
LD R2, MIN
NOT R2, R2		; INVERTED IT
ADD R2, R2, #1          ; #1 ;2S COMPLIMENT
ADD R2, R2, R0          ; CLEARS R2	    	
BRzp NOTMIN                
ST R0, MIN		; STORE VALUE TO MIN
NOTMIN

; CHECK FOR MAXIMUM
LD R2, MAX
NOT R2, R2		; INVERTED IT
ADD R2, R2, #1          ; #1 ;2S COMPLIMENT
ADD R2, R2, R0              		
BRnz NOTMAX                	
ST R0, MAX
NOTMAX

; CHECK FOR AVERAGE
ADD R4, R4, R0              	
ADD R6, R6, #1     	 ; #1 ;2S COMPLIMENT
LD R0, EMPTYROW             	
OUT
BRnzp OUTPUTLOOP            	
ENDOUTPUTLOOP
LD R0, EMPTYROW             	
OUT

; CALCULATES AVERAGE
LD R1, LOOPCOUNTER
NOT R1, R1		; INVERTED IT
ADD R1, R1, #1     	; #1 ;2S COMPLIMENT
ADD R0, R4, #0     	; COPY R4 TO R0	
JSR DIV
ST R0, AVG		; STORE VALUE TO AVG

; DISPLAYS THE MINIMUM GRADE
LEA R0, MINIMUMTEXT			
PUTS					
LD R0, MIN				 
JSR DISPLAYNUMBER 			
ADD R2, R0, #0		; COPY R0 TO R2	
LD R0, SPACE			
OUT						
ADD R0, R2, #0		; COPY R2 TO R0		
JSR DISPLAYSGRADE			
LD R0, EMPTYROW 			
OUT						

; DISPLAYS THE MAXIMUM GRADE
LEA R0, MAXIMUMTEXT 			
PUTS 					
LD R0, MAX 				
JSR DISPLAYNUMBER		
ADD R2, R0, #0		; COPY R0 TO R2
LD R0, SPACE			
OUT						
ADD R0, R2, #0		; COPY R2 TO R0	
JSR DISPLAYSGRADE			
LD R0, EMPTYROW 			
OUT						

; DISPLAYS THE MINIMUM GRADE
LEA R0, AVERAGETEXT			
PUTS					
LD R0, AVG				
JSR DISPLAYNUMBER		
ADD R2, R0, #0		; COPY R0 TO R2
LD R0, SPACE			
OUT				
ADD R0, R2, #0		; COPY R2 TO R0	
JSR DISPLAYSGRADE			
LD R0, EMPTYROW			
OUT						
HALT									
  					

; DISPLAY TO CONSOLE AND INPUT NUMBERS 
USERINPUT		.STRINGZ "Enter a grade 0-100 #"
ENDCHECK		.STRINGZ ": "
OUTPUTGRADE	       	.STRINGZ "Grade "
MINIMUMTEXT		.STRINGZ "Minimum: "
MAXIMUMTEXT		.STRINGZ "Maximum: "
AVERAGETEXT	       	.STRINGZ "Average: "
CHARACTERCOMP		.FILL x30
NEGCHARACTERCOMP 	.FILL x-30
LOOPCOUNTER	        .FILL #-5
BASEMINIMUM	        .FILL #10000
BASEMAXIMUM	        .FILL #0

; VARIABLES
MIN	                .FILL #0
MAX	                .FILL #0
AVG	                .FILL #0
EMPTYROW	        .FILL xA
SPACE	            	.FILL x20
STACKSIZE	        .FILL x0
POINTER		        .FILL x4000

;MULTIPLICATION HANDLER
MULT1
ST R1, SAVEREG1		; STORE VALUE TO REGISTERS
ST R2, SAVEREG2		; STORE VALUE TO REGISTERS	
ST R3, SAVEREG3		; STORE VALUE TO REGISTERS	
ST R4, SAVEREG4		; STORE VALUE TO REGISTERS	
ST R6, SAVEREG6		; STORE VALUE TO REGISTERS	
AND R3, R3, #0		; CLEARS R3			 
AND R4, R4, #0		; CLEARS R4				
AND R6, R6, #0		; CLEARS R6				
ADD R6, R6, #1		; #1 ;2S COMPLIMENT			

ADD R2, R0, #0		; COPY R0 TO R2	
BRzp MULT_INPUTNOTNEG		
ADD R4, R4, #1		; #1 ;2S COMPLIMENT		
NOT R0, R0		; INVERTED IT			
ADD R0, R0, #1		; #1 ;2S COMPLIMENT
MULT_INPUTNOTNEG
ADD R2, R1, #0		; COPY R1 TO R2
BRzp MULT_LOOP				
ADD R4, R4, #1		; #1 ;2S COMPLIMENT			
NOT R1, R1		; INVERTED IT			
ADD R1, R1, #1		; #1 ;2S COMPLIMENT;#1 

; MAIN LOOP
MULT_LOOP
AND R2, R6, R1				
BRz MULT_SKIPADD			
ADD R3, R0, R3				
MULT_SKIPADD
ADD R0, R0, R0				
ADD R6, R6, R6				
BRz MULT_END				
BRnzp MULT_LOOP				
MULT_END
AND R4, R4, #1		; #1 ;2S COMPLIMENT
BRz MULT_NOTNEG
NOT R3, R3		; INVERTED IT			
ADD R3, R3, #1		; #1 ;2S COMPLIMENT		
MULT_NOTNEG
ADD R0, R3, #0		; COPY R3 TO R0

; LOADING REGISTERS
LD R1, SAVEREG1		; RESTORE R1
LD R2, SAVEREG2		; RESTORE R2
LD R3, SAVEREG3		; RESTORE R3
LD R4, SAVEREG4		; RESTORE R4
LD R6, SAVEREG6		; RESTORE R6
RET					
; END OF MULTIPLICATION HANDLER

; DISPLAYUNMBER SUBROUTINE
DISPLAYNUMBER
    ST R0, DISPLAYREG0	; STORE VALUE TO REGISTERS
    ST R1, DISPLAYREG1	; STORE VALUE TO REGISTERS
    ST R2, DISPLAYREG2	; STORE VALUE TO REGISTERS
    ST R3, DISPLAYREG3	; STORE VALUE TO REGISTERS
    ST R4, DISPLAYREG4	; STORE VALUE TO REGISTERS
    ST R5, DISPLAYREG5	; STORE VALUE TO REGISTERS
    ST R6, DISPLAYREG6	; STORE VALUE TO REGISTERS
    ST R7, DISPLAYREG7	; STORE VALUE TO REGISTERS
    LD R4, CHARACTERCOMP		
    AND R3, R3, #0	; CLEARS R3			
    LD R5, NUM1000				
    ADD R2, R0, #0	; COPY R0 TO R2
    BRzp DISPLAYNUMBER_LOOP		
    LD R0, DASH
    OUT
    NOT R2, R2		; INVERTED IT			
    ADD R2, R2, #1 	; #1 ;2S COMPLIMENT				

    DISPLAYNUMBER_LOOP
    ADD R6, R5, #-1				
    BRz DISPLAYNUMBER_END		
    ADD R0, R2, #0	; COPY R2 TO R0			
    ADD R1, R5, #0	; COPY R5 TO R1
    JSR DIV						
    ADD R3, R3, R0				
    BRz DISPLAYNUMBER_SKIP		
    ADD R0, R0, R4				
    OUT							

    DISPLAYNUMBER_SKIP
    ADD R2, R1, #0	; COPY R1 TO R2		
    ADD R0, R5, #0	; COPY R5 TO R0		
    AND R1, R1, #0	; CLEARS R1
    ADD R1, R1, #10	; R1 = #10, COUNT IN FOR LOOP
    JSR DIV						
    ADD R5, R0, #0	; COPY R0 TO R5		
    BRnzp DISPLAYNUMBER_LOOP	
    DISPLAYNUMBER_END
    ADD R0, R2, R4				
    OUT							

    LD R0, DISPLAYREG0	
    LD R1, DISPLAYREG1	
    LD R2, DISPLAYREG2	
    LD R3, DISPLAYREG3	
    LD R4, DISPLAYREG4	
    LD R5, DISPLAYREG5	
    LD R6, DISPLAYREG6	
    LD R7, DISPLAYREG7	
    RET							
;END OF DISPLAYUNMBER SUBROUTINE

;NUBMER DIVISION 
DIV
    ST R2, SAVEREG2	; STORE VALUE TO REGISTERS		
    ST R3, SAVEREG3	; STORE VALUE TO REGISTERS
    ST R6, SAVEREG6	; STORE VALUE TO REGISTERS

    AND R3, R3, x0			 
    AND R6, R6, x0				
    AND R2, R2, x0				

    ;zero checker
    ADD R1, R1, #0	; CLEARS R1
    BRnp DIVISIONNOTZERO
    AND R0, R0, x0
    AND R1, R1, x0
    BRnzp DIVEND 
    DIVISIONNOTZERO

    ;negative checker
    ADD R0, R0, #0	; CLEARS R0
    BRzp DIVISIONNOTNEG0		
    ADD R6, R6, #1	; #1 ;2S COMPLIMENT			
    NOT R0, R0		; INVERTED IT			
    ADD R0, R0, #1	; #1 ;2S COMPLIMENT			
    DIVISIONNOTNEG0
    ADD R1, R1, #0	; CLEARS R1
    BRnz DIVISIONNEG1			
    NOT R1, R1		; INVERTED IT			
    ADD R1, R1, #1	; #1 ;2S COMPLIMENT			
    BRnzp DIVLOOP
    DIVISIONNEG1
    ADD R6, R6, #1	; #1 ;2S COMPLIMENT

    DIVLOOP						
    ADD R0, R0, R1				
    BRn DIVEND					
    ADD R3, R3, #1	; #1 ;2S COMPLIMENT			
    BRnzp DIVLOOP				
    DIVEND
    NOT R1, R1		; INVERTED IT			
    ADD R1, R1, #1	; #1 ;2S COMPLIMENT			
    ADD R2, R1, R0				
    AND R6, R6, x1				
    BRnz DIVISIONNEGPRODUCT		
    NOT R3, R3		; INVERTED IT
    ADD R3, R3, #1	; #1 ;2S COMPLIMENT
    NOT R2, R2		; INVERTED IT
    ADD R2, R2, #1	; #1 ;2S COMPLIMENT
    DIVISIONNEGPRODUCT
        
    ADD R0, R3, #0	; COPY R3 TO R0
    ADD R1, R2, #0	; COPY R2 TO R1

    LD R2, SAVEREG2	; RESTORE R2
    LD R3, SAVEREG3	; RESTORE R3
    LD R6, SAVEREG6	; RESTORE R6

    RET							
; END OF NUMBER DIVISION 

;STACK PUSH SUBROUTINE
PUSH
    ST R1, SAVEREG1	; STORE VALUE TO REGISTERS	
    ST R3, SAVEREG3	; STORE VALUE TO REGISTERS	
    LD R1, STACKSIZE	; RESTORE R1		
    ADD R1, R1, #1	; #1 ;2S COMPLIMENT			
    ST R1, STACKSIZE	; STORE VALUE TO STACKSIZE		
    LD R3, POINTER	; RESTORE R3		
    ADD R1, R1, R3				
    STR R0, R1, #0				
    LD R1, SAVEREG1	; RESTORE R1	
    LD R3, SAVEREG3 	; RESTORE R3	
    RET								
; END OF STACK PUSH SUBROUTINE

; STACK POP SUBROUTINE
POP
    ST R0, SAVEREG0	; STORE VALUE TO REGISTERS	
    ST R1, SAVEREG1	; STORE VALUE TO REGISTERS	
    ST R3, SAVEREG3 	; STORE VALUE TO REGISTERS	
    ST R7, SAVEREG7	; STORE VALUE TO REGISTERS	
    JSR EMPTY						
    ADD R0, R0, #0	; CLEARS R0
    BRp POPJUMP				
    LEA R0, POPERROR			
    PUTS						
    LD R7, SAVEREG7	; RESTORE R7	
    RET							

    LD R0, SAVEREG0	; RESTORE R0	
    POPJUMP				
    LD R1, STACKSIZE	; RESTORE R1		
    LD R3, POINTER	; RESTORE R3		
    ADD R1, R1, R3				
    LDR R0, R1, #0				
    AND R3, R3, #0	; CLEARS R3			
    STR R3, R1, #0				
    LD R1, STACKSIZE	; RESTORE R1		
    ADD R1, R1, #-1	; SUBTRACT 1 TO TEST FOR SIGN				
    ST R1, STACKSIZE	; STORE VALUE TO STACKSIZE		
    LD R1, SAVEREG1	; RESTORE R1	
    LD R3, SAVEREG3 	; RESTORE R3	
    LD R7, SAVEREG7	; RESTORE R7	
    RET							
; END OF STACK POP SUBROUTINE 

; EMPTY STACK SUBROUTINE
EMPTY
    LD R0, STACKSIZE	; RESTORE R0		
    BRz #2						
    AND R0, R0, #0	; CLEARS R0			
    ADD R0, R0, #1	; #1 ;2S COMPLIMENT			
    RET							
; END OF EMPTY SUBROUTINE

; START CEALR CONSOLE SUBROUTINE
CLEARSLINE	        .FILL #26		
CLEARS
    ST R0, SAVEREG0	; STORE VALUE TO REGISTERS
    ST R1, SAVEREG1     ; STORE VALUE TO REGISTERS		
    ST R7, SAVEREG7	; STORE VALUE TO REGISTERS	
    LD R0, EMPTYROW	; RESTORE R0	
    LD R1, CLEARSLINE	; RESTORE R1	
    CLEARSLOOP
    OUT							
    ADD R1, R1, #-1	; SUBTRACT 1 TO TEST FOR SIGN			
    BRp CLEARSLOOP
    LD R0, SAVEREG0	; RESTORE R0		
    LD R1, SAVEREG1	; RESTORE R1
    LD R7, SAVEREG7	; RESTORE R7
    RET							
; END CLEAR CONSOLE SUBROUTINE

; START DIGITNUMBER SUBROUTINE
DIGITNUMBER
    ST R1, DISPLAYREG1	; STORE VALUE TO REGISTERS
    ST R2, DISPLAYREG2	; STORE VALUE TO REGISTERS
    ST R3, DISPLAYREG3	; STORE VALUE TO REGISTERS
    ST R4, DISPLAYREG4	; STORE VALUE TO REGISTERS
    ST R6, DISPLAYREG6  ; STORE VALUE TO REGISTERS
    ST R7, DISPLAYREG7  ; STORE VALUE TO REGISTERS

    LD R1, POINTER	; RESTORE R1	
    LD R3, STACKSIZE	; RESTORE R3	
    ADD R6, R1, R3			
    AND R3, R3, #0	; CLEARS R3		
    AND R1, R1, #0	; CLEARS R1	
    ADD R1, R1, #1	;#1 ;2S COMPLIMENT
    ADD R2, R0, #0	; COPY R0 TO R2		
    DIGITNUMBER_LOOP			
    ADD R2, R2, #-1	; SUBTRACT 1 TO TEST FOR SIGN		
    BRn DIGITNUMBER_END
    LDR R0, R6, #0		
    JSR MULT1				
    ADD R3, R3, R0			
    LD R0, NUM10	; RESTORE R0
    JSR MULT1				
    ADD R1, R0, #0	; COPY R0 TO R1
    ADD R6, R6, #-1	; SUBTRACT 1 TO TEST FOR SIGN		
    BRnzp DIGITNUMBER_LOOP		
    DIGITNUMBER_END
    ADD R0, R3, #0	; COPY R3 TO R0	

    LD R1, DISPLAYREG1	; RESTORE R1
    LD R2, DISPLAYREG2	; RESTORE R2
    LD R3, DISPLAYREG3	; RESTORE R3
    LD R4, DISPLAYREG4	; RESTORE R4
    LD R6, DISPLAYREG6	; RESTORE R6
    LD R7, DISPLAYREG7	; RESTORE R7
    RET						
; END OF DIGITNUMBER SUBROUTINE

; DISPLAY GRADE SUBROUTINE
GRADE_A	           	.FILL #-90
GRADE_B	            	.FILL #-80
GRADE_C	            	.FILL #-70
GRADE_D	            	.FILL #-60
CHAR_A	           	.FILL x41
CHAR_B	           	.FILL x42
CHAR_C	            	.FILL x43
CHAR_D	           	.FILL x44
CHAR_F	           	.FILL x46

DISPLAYSGRADE
    ST R0, SAVEREG0	; STORE VALUE TO REGISTERS
    ST R1, SAVEREG1	; STORE VALUE TO REGISTERS
    ST R7, SAVEREG7	; STORE VALUE TO REGISTERS
    LD R1, GRADE_A	; RESTORE R1
    ADD R1, R0, R1
    BRn DISPLAYSGRADE_A
    LD R0, CHAR_A	; RESTORE R0
    OUT
    BRnzp DISPLAYSGRADE_END
    DISPLAYSGRADE_A
    LD R1, GRADE_B	; RESTORE R1
    ADD R1, R0, R1
    BRn DISPLAYSGRADE_B
    LD R0, CHAR_B	; RESTORE R0
    OUT
    BRnzp DISPLAYSGRADE_END
    DISPLAYSGRADE_B
    LD R1, GRADE_C
    ADD R1, R0, R1
    BRn DISPLAYSGRADE_C
    LD R0, CHAR_C	; RESTORE R0
    OUT
    BRnzp DISPLAYSGRADE_END
    DISPLAYSGRADE_C
    LD R1, GRADE_D	; RESTORE R1
    ADD R1, R0, R1
    BRn DISPLAYSGRADE_D
    LD R0, CHAR_D	; RESTORE R0
    OUT
    BRnzp DISPLAYSGRADE_END
    DISPLAYSGRADE_D

    ; IF NONE ARE TRUE THEN THEN OUTPUT TO CHAR F
    LD R0, CHAR_F	; RESTORE R0
    OUT
    DISPLAYSGRADE_END
    LD R0, SAVEREG0	; RESTORE R0
    LD R1, SAVEREG1	; RESTORE R1
    LD R7, SAVEREG7	; RESTORE R7
    RET
; END OF DISPLAYGRADE SUBROUTINE

;value holder
SAVEREG0		.FILL #0
SAVEREG1		.FILL #0
SAVEREG2		.FILL #0
SAVEREG3		.FILL #0
SAVEREG4		.FILL #0
SAVEREG5		.FILL #0
SAVEREG6		.FILL #0
SAVEREG7		.FILL #0
DISPLAYREG0		.FILL #0
DISPLAYREG1		.FILL #0
DISPLAYREG2		.FILL #0
DISPLAYREG3		.FILL #0
DISPLAYREG4		.FILL #0
DISPLAYREG5		.FILL #0
DISPLAYREG6		.FILL #0
DISPLAYREG7		.FILL #0
  


;CONSTANTS
NUM1000	       		.FILL #10000
NUM10		        .FILL #10
POPERROR	        .STRINGZ "STACK IS EMPTY"
DASH	                .FILL x2D

FAIL_STR		.STRINGZ "INVALID ENTRY RESTARTING... "
RESTART			.FILL X3000
DATA_MIN		.FILL #-48
DATA_MAX		.FILL #-57
NEWLINE2		.FILL XA
.END
